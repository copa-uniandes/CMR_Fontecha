package P1;


import gurobi.*;

import java.util.ArrayList;


import java.util.Hashtable;

import router.RNode;
/**
 * This class
 * @author 	/Daniel Duque
 * 			/d.duque25@uniandes.edu.co
 * 			/Universidad de los Andes
 *			/Departamento de Ingeniería Industrial
 *			/Combined Maintenance and Routing Optimization for large scale problems
 */
public class Split 
{
	public ArrayList<FeasibleRoute> feasibleRoutes=new ArrayList<FeasibleRoute>();
	public int iterator=0;

	public DataHandler data;
	/**
	 * Vector that stores the TSP. In each position i, it saves the id of the
	 * node that is placed in the i-th position of the TSP.
	 */
	public int [] rutaTSP;

	/**
	 * Saves the arcs encountered in the procedure.
	 */
	public int [][] arcosSplit;

	/**
	 * Cost of each arc founded in the split procedure.
	 */
	public double [] costoArcosSplit;

	/**
	 * Total number of split arcs.
	 */
	public int splitTotalArcs;

	/**
	 * costo de todas las rutas
	 */
	public double vrpCost;

	/**
	 * Boolean flag to indicate whether an arc is extensible or not.
	 */
	private boolean extensible;
	/**
	 * Boolean flag to indicate whether an arc is feasible or not.
	 */
	private boolean feasible;

	/*--START------Gurobi-----------*/
	/**
	 * Gurobi environment
	 */
	private GRBEnv env;
	/**
	 * Gurobi Model
	 */
	private GRBModel model;
	/**
	 * Decision variable represeting the time to serve node v_i.
	 */
	private GRBVar[] s;
	/**
	 * Binary variable representing if node i is served on day j on the work shift h. 
	 */
	private GRBVar[][][] y;
	/**
	 * Cost (linear) of node i
	 */
	private GRBVar[] z;

	/**
	 * Nodes that are part of route that is being evaluated. This ArrayList will
	 * help to easily reset the MIP model.
	 */
	private ArrayList<Integer> activeNodes;

	/**
	 * Cost of the route that is being evaluated.
	 */
	public double routeCost;

	private String routeName;
	/**
	 * If the route that id being evaluated is feasible 
	 */
	private boolean routeFeasibility;
	/*--------Gurobi---------END--*/


	/**
	 * Constructor of the class. Build the MIP that is going to be used through
	 * out the procedure.
	 * @param nData
	 *instance of the data
	 */
	public Split(DataHandler nData)
	{
		data = nData;
		buildMIP();
	}

	/**
	 * This method runs the split procedure.
	 * 
	 * @param ruta
	 * @return
	 */
	public Rutas excecute(ArrayList<Integer> ruta) {
//		for(int h=0;h<ruta.size();h++){
//		System.out.println(ruta.get(h));
//		}
		setRutaTSP(ruta);
		return buildAndSolve();
	}

	/**
	 * Sets the vector for the SPLIT procedure given a tour generated by any heuristic. 
	 * 
	 * @param newRoute route obtained from CW, NN, or any other heuristic.
	 */
	private void setRutaTSP(ArrayList<Integer> newRoute)
	{
		rutaTSP = new int [data.n];
		//		System.out.println("N: "+data.n);
		for (int i = 0; i < data.n; i++) 
		{
			rutaTSP[i]=newRoute.get(i);	
		}
	}

	/**
	 * Creates the arcs of the auxiliary graph used in split. TODO: Solve the
	 * problem simultaneously.
	 * @return 
	 */
	private Rutas buildAndSolve() {

		double tiempo=System.currentTimeMillis();
		Rutas rutas = new Rutas(data);
		int numArcos = (data.n * (data.n - 1)) / 2;

		// Split
		splitTotalArcs = 0;
		arcosSplit = new int[numArcos][2];
		costoArcosSplit = new double[numArcos]; //Esto es lo de la desigualdad traingular?

		// START------Shortes path labels------------
		int[] pred = new int[data.n];
		String[] ArcoLlegada = new String[data.n];
		pred[0] = -1;
		double[] label = new double[data.n];
		for (int i = 1; i < label.length; i++) {
			label[i] = Double.POSITIVE_INFINITY;
		}

		// ------Shortes path labels--------END
		activeNodes = new ArrayList<Integer>(data.n);

		ArrayList<Integer> route;

		readyMIP();

		for (int i = 0; i < data.n - 1; i++) {
			readyMIP();
			activeNodes.clear();
			extensible = true;
			route = new ArrayList<Integer>();
			route.add(0);
			for (int j = i + 1; j < data.n && extensible; j++) {
				int nodei = rutaTSP[i];
				int nodej = rutaTSP[j];
				int nodejLast = 0;
				if (j - i != 1) {
					nodejLast = rutaTSP[j - 1];
				}
//				System.out.println("nodo adicionado: "+nodej);
				route.add(nodej);
				activeNodes.add(nodej);
//				System.out.println("node i: "+nodei+"va a encender a " +nodej);
				turnOnVar(nodej);
				evaluateSplitArc(route);
			}
//			System.out.println("Nueva ruta");
			resetModel();
		}
		//		System.out.println("Ya casi retorna algo "+(System.currentTimeMillis()-tiempo));
		//		System.out.println("Total rutas encontradas: "+feasibleRoutes.size());
		return rutas;
	}

	/**
	 * Solves the split, should be integrated
	 * Also extracts the solution and build an ArrayList of routes.
	 * 
	 * @return List of routes. Each route saves the information of the sequence,
	 *         OF, and s[i] variables.
	 */
	private Rutas solveSplit(Rutas rutas) {
		return rutas;
	}

	/**
	 * When the split arcs are no longer extensible the model returns to the
	 * original setup, i.e., variables are bounded to 0 to do not us them unless
	 * necessary. Also, constraints related to arrival time are deleted. 
	 * @throws GRBException 
	 */
	private void resetModel()  {
		buildMIP();
		activeNodes.clear();
	}

	/**
	 * Before the split procedure starts, this method turn on variables related
	 * with the depot
	 */
	private void readyMIP() {
		try {	
			s[0].set(GRB.DoubleAttr.LB, data.getTmin());
			s[0].set(GRB.DoubleAttr.UB, data.getTmax());

			if(data.getMIPShifts()=="on"){

			}else{
				GRBLinExpr convexity=new GRBLinExpr();
				for (int i = 0; i < 1; i++) {
					for (int j = 0; j < data.getNumDays(); j++) {
						for (int k = 0; k < data.getNumShifts(); k++) {
							y[i][j][k].set(GRB.DoubleAttr.UB,1);
							convexity.addTerm(1,y[0][j][k]);
						}
					}
				}			
				model.addConstr(convexity, GRB.EQUAL, 1, "convex"+0);
				//Constraint on the limits of s_i and convexity of y's
				GRBLinExpr exp1, exp2;
				for (int d = 0; d < data.getNumDays(); d++) {
					for (int k = 0; k < data.getNumShifts(); k++) {
						exp1=new GRBLinExpr();
						exp1.addTerm(1,s[0]);
						exp1.addTerm(-(data.getTmin()+data.getL()[k] + d),y[0][d][k]);
						model.addConstr(exp1, GRB.GREATER_EQUAL, 0, "sLB,"+0+","+d+","+k);
						exp2 = new GRBLinExpr();
						exp2.addTerm(1, s[0]);
						exp2.addTerm(-(data.getTmin()+data.getU()[k] + d-data.getTmax()),y[0][d][k]);
						model.addConstr(exp2, GRB.LESS_EQUAL, data.getTmax(), "sUB,"+0+","+d+","+k);
					}
				}
			}		
			model.update();			
			//						model.write("ReadyMIP_"+".lp");
			//			System.out.println("Ready MIP");

		} catch (GRBException e) {
			e.printStackTrace();
		}
	}

	/**
	 * When a new node is added to a route (the arc was extended), bounds,
	 * objective function coefficients, and constraints coefficients change to
	 * be usable.
	 * 
	 * @param v_i : the id of the node that was added to the route. 
	 */
	private void turnOnVar(int v_i){
		try {

			if(data.getMIPShifts()=="on"){

			}else{
				for (int i = v_i; i <v_i+ 1; i++) {
					for (int j = 0; j < data.getNumDays(); j++) {
						for (int k = 0; k < data.getNumShifts(); k++) {
							y[v_i][j][k].set(GRB.DoubleAttr.UB, 1);// = model.addVar(0, 1,0, GRB.BINARY, "y,"+i+","+j+","+k);
						}
					}
				}
			}


			s[v_i].set(GRB.DoubleAttr.LB, data.getTmin());
			s[v_i].set(GRB.DoubleAttr.UB, data.getTmax());
			z[v_i].set(GRB.DoubleAttr.Obj, 1);

			GRBLinExpr exp1, exp2, convexity;
			if(data.getMIPShifts()=="on"){

			}else{
				//Constraint on the limits of s_i and convexity of y's
				convexity = new GRBLinExpr();
				for (int d = 0; d < data.getNumDays(); d++) {
					for (int k = 0; k < data.getNumShifts(); k++) {
						exp1=new GRBLinExpr();
						exp1.addTerm(1,s[v_i]);
						exp1.addTerm(-(data.getTmin()+data.getL()[k] + d),y[v_i][d][k]);
						model.addConstr(exp1, GRB.GREATER_EQUAL, 0, "sLB,"+v_i+","+d+","+k);
						exp2 = new GRBLinExpr();
						exp2.addTerm(1, s[v_i]);
						exp2.addTerm(-(data.getTmin()+data.getU()[k] + d-data.getTmax()),y[v_i][d][k]);
						model.addConstr(exp2, GRB.LESS_EQUAL, data.getTmax(), "sUB,"+v_i+","+d+","+k);
						convexity.addTerm(1,y[v_i][d][k]);
					}
				}
				model.addConstr(convexity, GRB.EQUAL, 1, "convex"+v_i);
			}


			RNode v_i2;
			int pieces;
			//			for (int i = 0; i < N; i++) {
			v_i2 = data.getGraph().getNodes().get(v_i);
			pieces = v_i2.getPieces().length;
			for (int o = 0; o < pieces; o++) {
				exp1 = new GRBLinExpr();
				exp1.addTerm(v_i2.getPieces()[o][0], s[v_i]);
				exp1.addConstant(v_i2.getPieces()[o][1]);
				model.addConstr(exp1, GRB.LESS_EQUAL, z[v_i], "pwa,"+v_i+","+o);
			}
			model.update();
			//						model.write("Turnonvar_"+".lp");
			//			System.out.println("Turnonvar MIP");

		} catch (GRBException e) {
			e.printStackTrace();
		}
	}

	/**
	 * When a node is no longer on a route (split arcs change origin node), bounds, objective function
	 * coefficients, and constraints coefficients are to disable the variables.
	 * 
	 * @param v_i the id of the node that is not longer in routes. 
	 */
	private void turnOffVar(int v_i){
		try {
			s[v_i].set(GRB.DoubleAttr.UB, 0);
			//			z[i].set(GRB.DoubleAttr.UB, 0);
			z[v_i].set(GRB.DoubleAttr.Obj, 0);

			if(data.getMIPShifts()=="on"){

			}else{
				for (int j = 0; j < data.getNumDays(); j++) {
					for (int k = 0; k < data.getNumShifts(); k++) {
						y[v_i][j][k].set(GRB.DoubleAttr.UB, 0);
						model.chgCoeff(model.getConstrByName("convex"+0), y[0][j][k] , 0);
					}
				}	
			}
			model.update();
			//						model.write("turnoffVar"+".lp");
			//			System.out.println("Turnoffvar");
		} catch (GRBException e) {
			e.printStackTrace();
		}
	}

	/**
	 * To evaluate an arc in the split procedure, the MIP model is updated with
	 * one constraint and is then solved. If the model is feasible, the cost of 
	 * the arc is saved in a field and it corresponds to the objective function 
	 * of the model.
	 * 
	 * @param route The route corresponding to the arc in the split procedure.
	 * @return <code>true</code> if the arc/route is feasible, <code>false</code> otherwise. 
	 */
	private boolean evaluateSplitArc(ArrayList<Integer> route) {
//		System.out.println();
		try{
			int lastAdded = route.get(route.size()-1);
			int beforeLast = route.get(route.size()-2);
			GRBLinExpr time;
			if(beforeLast == 0){
				time = new GRBLinExpr();
				time.addTerm(1, s[beforeLast]);
				time.addTerm(-1, s[lastAdded]);
				time.addConstant(data.times[beforeLast][lastAdded]);//time.addConstant(data.times[beforeLast][lastAdded]+data.service[beforeLast]);
			}else{
				time = new GRBLinExpr();
				time.addTerm(1, s[beforeLast]);
				time.addTerm(-1, s[lastAdded]);
				time.addConstant(data.times[beforeLast][lastAdded]+data.service[beforeLast]);			
			}

			model.addConstr(time, GRB.LESS_EQUAL, 0, "arriving"+lastAdded);
			model.update();
			//			model.write("evaluate split arc.lp");
			model.optimize();

			if(model.get(GRB.IntAttr.Status)==GRB.OPTIMAL){
				ArrayList<Integer> route2=new ArrayList<Integer>();
				ArrayList<Double> soluciones=new ArrayList<Double>();
//				System.out.println("la ruta es: ");
				for(int l =0;l<route.size();l++){			
//					System.out.println(route.get(l));
					route2.add(route.get(l));	
					soluciones.add(s[route.get(l)].get(GRB.DoubleAttr.X));	
//					if(iterator==522){
//						System.out.println("va escribir");
//						System.out.println(route.get(l)+" "+s[route.get(l)].get(GRB.DoubleAttr.X)+" "+z[route.get(l)].get(GRB.DoubleAttr.X));
//						RNode v_i2;
//						int pieces;
//						//			for (int i = 0; i < N; i++) {
//						v_i2 = data.getGraph().getNodes().get(l);
//						pieces = v_i2.getPieces().length;
//						for (int o = 0; o < pieces; o++) {
//							System.out.println(v_i2.getPieces()[o][0]+" "+v_i2.getPieces()[o][1]);
//						}
//					}
				}
//				if(iterator==522){
//					System.out.println("costo ruta: "+model.get(GRB.DoubleAttr.ObjVal));
//				}
				iterator=iterator+1;
				double costo=model.get(GRB.DoubleAttr.ObjVal);
				routeCost = model.get(GRB.DoubleAttr.ObjVal);
				routeFeasibility=true;
				FeasibleRoute fr = new FeasibleRoute(soluciones,route2,costo);
				routeName = fr.pathToString();
				feasibleRoutes.add(fr);
			}else{
				//					System.out.println("Se hizo infactible");
				extensible = false;
				routeFeasibility= false;
				routeCost = Double.POSITIVE_INFINITY;
			}
		}catch(GRBException e){
			e.printStackTrace();
		}
		return routeFeasibility;
	}
	//	}

	/**
	 * Build the MIP model. All variables are locally saved for later usage. 
	 * All constraints are builded, and convexity constraint is created with 
	 * a cero as a coefficient to avoid an infeasible model. 
	 */
	private void buildMIP() {
		try{
			env = new GRBEnv();
			env.set(GRB.IntParam.OutputFlag, 0);
			model = new GRBModel(env);
			int N = data.n;
			int D = (int) data.getNumDays();
			int K = data.getNumShifts();

			s = new GRBVar[N];
			z = new GRBVar[N];


			for (int i = 0; i < N; i++) {
				s[i] = model.addVar(0, 0, 0, GRB.CONTINUOUS, "s" + i);
				z[i] = model.addVar(0, Double.POSITIVE_INFINITY, 0, GRB.CONTINUOUS, "z" + i); //yo creo que se puede quitar este ""
			}

			if(data.getMIPShifts()=="on"){

			}else{
				y = new GRBVar[N][D][K];
				for (int i = 0; i < N; i++) {
					for (int j = 0; j < D; j++) {
						for (int k = 0; k < K; k++) {
							y[i][j][k] = model.addVar(0, 0,0, GRB.BINARY, "y,"+i+","+j+","+k);
						}
					}
				}
			}
			//
			model.update();
		}catch(GRBException e){
			e.printStackTrace();
		}
	}

	/**
	 * Return the objective function of the VRP problem, i.e., the sum the cost
	 * of the routes selected by the split procedure.
	 * 
	 * @return Numerical value of the objective function of the VRP
	 */
	public double getFO() 
	{
		return vrpCost;
	}

	public ArrayList<FeasibleRoute> getFeasibleRoutes() {
		return feasibleRoutes;
	}

	public void setFeasibleRoutes(ArrayList<FeasibleRoute> feasibleRoutes) {
		this.feasibleRoutes = feasibleRoutes;
	}

}


