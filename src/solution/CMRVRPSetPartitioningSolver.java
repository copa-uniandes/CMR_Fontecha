package solution;
/*
 * Log of changes:
 * 2011.02.18 Moved to package setCoveringSolvers (J.E.Mendoza)
 * 2011.02.19 Changed class name from heuristicConcentration to VRPSetCoveringSolver (J.E. Mendoza)
 */

import gurobi.GRB;
import gurobi.GRBColumn;
import gurobi.GRBConstr;
import gurobi.GRBEnv;
import gurobi.GRBException;
import gurobi.GRBLinExpr;
import gurobi.GRBModel;
import gurobi.GRBVar;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import setCoveringSolvers.IColumn;
import setCoveringSolvers.ISetCoveringSolver;

/**
 * Implements a Set Covering Solver using Gurobi 
 * @author Juan G. Villegas (jvillega@udea.edu.co)
 * @since 2011.02.11
 * @version 2011.03.11
 */
public class CMRVRPSetPartitioningSolver implements ISetCoveringSolver{

	/**
	 *  Environment of gurobi where the model will be created
	 */
	public GRBEnv  env;  

	/**
	 * Number of customers of the underlying VRP needed to create the model
	 */
	public int numCusVRP;		


	/**
	 * Zero tolerance
	 */
	final double eps=10e-5;

	/**
	 * Flag to know if there are columns for a MIP Star  
	 */
	public boolean mipStartFlag;

	/**
	 * Columns stored for a MIP Start
	 */
	public ArrayList<IColumn> startColumns;
	/**
	 * Holds the objective function
	 */
	private double of;

	/**
	 * Constructor specifying the output level
	 * @param int outputLevel of the environment 0: no output 1: verbose
	 * @param int numCus  
	 * @throws GRBException 
	 */
	public CMRVRPSetPartitioningSolver(int outputLevel, int numCus) {
		numCusVRP=numCus;
		try {
			env = new GRBEnv("SetCoveringniando.log");
		} catch (GRBException e) {
			System.out.println("Heuristic_Concentration> Problem creating the environment");
			e.printStackTrace();
		}
		mipStartFlag=false;
		startColumns=new ArrayList<IColumn>();
	}

	/** This method gets a pool of columns generated by a metaheuristic method for a VRP variant and
	 * generates a probably better solution by formulating a Set Covering Problem over the columns
	 * @param  Collection<IColumn> columnSet pool of columns 
	 * @return The subset of the columns selected in the optimal solution of the Set Covering Model  
	 */
	public Collection<IColumn> solve(Collection<IColumn> columnSet) {
		ArrayList<IColumn> selectedCols=new ArrayList<IColumn>();	//Array list of columns that will be returned after the optimization
		GRBModel model= null;
		try {
			model = new GRBModel(env);								//Gurobi Model where the Set Covering will be built
		} 
		catch (GRBException e1) {
			System.out.println("Heuristic_Concentration> Error creating the Gurobi Model");
			e1.printStackTrace();
		};										
		//Begin: -------------------CREATION OF THE MODEL-------------------------------------------------------
		// Begin: Add empty constraints one for each customer 
		String str; 
		for(int i=0;i<numCusVRP;i++)
		{
			// Add constraint: for customer i
			GRBLinExpr expr = new GRBLinExpr();
			str=new String("c"+i);
			try {
				model.addConstr(expr, GRB.EQUAL,1.0,str);					//TODO CHECK SET COVERING OR SET PARTITIONING
			} 
			catch (GRBException e) {
				System.out.println("Heuristic_Concentration> Error while adding constraint " + i + " to the Model");
				e.printStackTrace();
			}
		}
		try {
			model.update();											//Don't forget to update the model!!
		} 
		catch (GRBException e) {
			System.out.println("Heuristic_Concentration> Error while updating the model");
			e.printStackTrace();
		}				
		// End: Constraints creation 
		//Begin: Column-wise model construction
		//---------------Variables------------------ 
		//Add variables
		GRBColumn col= new  GRBColumn();							//GUROBI Column that represents the route
		GRBConstr cons;											//Constraints with non zero in the column (i.e. served customers) 
		Iterator<IColumn> it=columnSet.iterator();
		IColumn HCCol;											//Column generated in the search (i.e. route from the pool of routes)
		// Add constraint capacity flet 
		GRBLinExpr capacity = new GRBLinExpr();					
		int k=0;													//Counter of columns of the Set covering formulation
		while(it.hasNext())
		{
			HCCol=it.next(); 				
			col= new  GRBColumn(); //
			str=new String("x_"+k);
			int numCusRoute=(Integer) HCCol.getAttribute(IColumn.ColumnAttribute.VISITED_CUSTOMERS);
			for(int i=0; i<numCusRoute;i++)						//Add ones in the rows of visited customers
			{
				cons=model.getConstrs()[HCCol.getSequence().get(i)-1]; 	//WARNING the constraints of the model are numbered from 0 to n-1 (customer covering constraints)   
				col.addTerm(1,cons);							
			}
			try {
				GRBVar x= model.addVar(0, 1, (Double)HCCol.getAttribute(IColumn.ColumnAttribute.COST), GRB.INTEGER, col,str);
				capacity.addTerm(1,x);
			} 
			catch (GRBException e) {
				System.out.println("Heuristic_Concentration> Error while adding variable  " + k + " to the Model");
				e.printStackTrace();
			}
			k++;
		}

		//---------------Variables------------------
		try {
			model.update();
			System.out.println("Cual es el valor de k " +k);
			System.err.println(capacity.size());
//			model.addConstr(capacity,GRB.LESS_EQUAL,5.0,"capacity");
			model.update();
			model.write("Modelitosexy.lp");
			
		} 
		catch (GRBException e) {
			System.out.println("Heuristic_Concentration> Error while updating the model");
			e.printStackTrace();
		}
		// ----------------Update and Optimize model----------
		//End: column-wise construction 
		//End: -------------------CREATION OF THE MODEL-------------------------------------------------------

		//Begin: -------------------WARM START -------------------------------------------------------   
		if(this.mipStartFlag){ 
			columnSet.addAll(this.startColumns);
			Iterator<IColumn> it2=this.startColumns.iterator();
			IColumn feasSolCol;							//Column of the provided feasible solution (It could be infeasible and the method still works (but fails to provide an upper bound))
//			capacity = new GRBLinExpr();	
			while(it2.hasNext())
			{
				feasSolCol=it2.next();
				col= new  GRBColumn(); //
				str=new String("x_"+k);
				int numCusRoute=(Integer) feasSolCol.getAttribute(IColumn.ColumnAttribute.VISITED_CUSTOMERS);
				for(int i=0; i<numCusRoute;i++)						//Add ones in the rows of visited customers 
				{
					cons=model.getConstrs()[feasSolCol.getSequence().get(i)-1]; 	//WARNING the constraints of the model are numbered from 0 to n-1 (customer covering constraints)   
					col.addTerm(1,cons);							
				}
				try {
					GRBVar x= model.addVar(0, 1, (Double)feasSolCol.getAttribute(IColumn.ColumnAttribute.COST), GRB.INTEGER, col,str);
					model.update();
					x.set(GRB.DoubleAttr.Start,1);
					capacity.addTerm(1,x);

				} 
				catch (GRBException e) {
					System.out.println("Heuristic_Concentration> Error while adding variable  " + k + " to the Model");
					System.out.println(e.getErrorCode());
					e.printStackTrace();
				}
				k++;
			}
			try {
				model.update();
				model.addConstr(capacity,GRB.LESS_EQUAL,5,"capacityconstraint");
				model.update();
				model.write("Modelitosexy3.lp");
				
			} 
			catch (GRBException e) {
				System.out.println("Heuristic_Concentration> Error while updating the model");
				e.printStackTrace();
			}
		}
		//end: -------------------WARM START -------------------------------------------------------
		//try {
		//model.write("Caro.lp");
		//} catch (GRBException e1) {
		// TODO Auto-generated catch block
		//	e1.printStackTrace();
		//}
		//Begin: -------------------OPTIMIZATION AND OPTIMUM SOLUTION INFORMATION-------------------------------------------------------
		try {
			model.write("Modelitosexy2.lp");
			model.optimize();
		} 
		catch (GRBException e) {
			System.out.println("Heuristic_Concentration> Error while solving the problem");
			e.printStackTrace();
		}
		int status;
		try {
			status = model.get(GRB.IntAttr.Status);
			if(status==GRB.Status.OPTIMAL){
				selectedCols=this.selectColumns(model, (ArrayList<IColumn>)columnSet);
				this.of=model.get(GRB.DoubleAttr.ObjVal);
			}
		} catch (GRBException e1) {
			e1.printStackTrace();
		}

		//End: -------------------OPTIMIZATION AND OPTIMUM SOLUTION INFORMATION-------------------------------------------------------
		return selectedCols;
	}


	private ArrayList<IColumn> selectColumns(GRBModel model,ArrayList<IColumn> columnSet){
		int i=0;
		ArrayList<IColumn> selectedCols=new ArrayList<IColumn>();
		for (GRBVar v : model.getVars()) 
		{
			double sol;
			try {
				sol = v.get(GRB.DoubleAttr.X);
				if(sol>eps)
				{					
					selectedCols.add(columnSet.get(i)); 
				}
			} 
			catch (GRBException e) {
				System.out.println("Heuristic_Concentration> Error while reading solution for variable "+ i);
				return new ArrayList<IColumn>();
			}
			i++;
		}
		return selectedCols;
	}

	/**
	 * This method stores the information to perform a MIP Start in Gurobi 
	 * and changes the flag to control the initialization when solving the Set Covering Problem
	 * @param  columnSet Columns that will be stored for the MIP Start 
	 * @see setCoveringSolvers.ISetCoveringSolver#warmUp(java.util.Collection)
	 */
	public void warmUp(Collection<IColumn> columnSet) {
		mipStartFlag=true;
		startColumns.addAll(columnSet);	
	}

	public double getOF(){
		return this.of;
	}
}
